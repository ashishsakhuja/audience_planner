generate_sql_task:
  description: >
    Generate a precise SQL statement for the segments table based on the
    user's campaign query "{query}".
    **IMPORTANT** DO NOT APPEND LIMIT HERE. Return the full SELECT so we can count
    **IMPORTANT** DO NOT TRY AND MATCH INTERESTS OR PRODUCTS, analyze the query to determine which demographics to query for.
  expected_output: >
    A single SQL SELECT statement (ending with a semicolon).
  agent: database_guru


select_segment_task:
  description: |
    Search all segments loaded from the official knowledge source for the campaign query "{query}".  
    1. Take SQL from 'generate_sql_task'
        1. Wrap it in a COUNT query (use **size**, not "segment_size"):
        CALL SegmentSQLTool(query="
          SELECT COUNT(*) AS totalMatches
            FROM ({{context.generate_sql_task.pydantic.sql.rstrip(';')}}) AS sub;
          ")
    3. THIS COUNT IS YOUR "totalMatches" field.
       IMPORTANT: NOTE THAT THIS IS THE TOTAL MATCHING SEGMENTS, THIS SHOULD BE A LARGER NUMBER THAN 5.
    4. Call the SegmentSQLTool with the same SQL to get the full array of segments
    6. Then list the top best‐matching segments in markdown, using exactly these fields:
      - **name**, **segmentId**, **age_range**, **income_level**, **location_type**, **recency**, **cpm**, **confidence**, **estimated_reach**
    Only use data from the source file; do not infer or invent any values.
  expected_output: >
    [totalMatches] total segments match the campaign query.
    
    ### [segment name 1]
    - **segmentId**: [UUID]
    - **age_range**: [value]
    - **income_level**: [value]
    - **location_type**: [value]
    - **recency**: [value]
    - **cpm**: [value]
    - **confidence**: [value]
    - **estimated_reach**: [value]
    
    ### [segment name 2]
    …  (up to 5 segments)
  agent: segment_agent
  depends_on: [generate_sql_task]


validate_segment_task:
  description: >
    Validate whether the recommended segments match the campaign query: "{query}".
    The first line you received from the "segment agent" is structured like this: 
    "There were 126 segments that matched your campaign query"
    In this example 126 is your total matches. Whatever this number is, DO NOT CHANGE THIS NUMBER, SIMPLY PUT IT AS "totalMatches" in the output.
    THIS NUMBER IS NOT 5, IT IS THE TOTAL NUMBER OF MATCHING SEGMENTS.
    
    

    For each recommended segment, cross-check every field with the source data (age_range, income_level, location_type, recency, taxonomyId, cpm).
    Do not guess or infer values.
    
    IMPORTANT: You must return the **full** **completed** recommended segments list (All recommended segments, all attributes, all Matches/Mismatches, all explanations)
    IMPORTANT: Limit the segments returned to 5 segments, but do not artificially restrict to 3.
    IMPORTANT: segmentId must match the exact UUID from segment.segmentId. Do not repeat or reuse IDs across segments.
    IMPORTANT: Only flag mismatches if the campaign query explicitly defines required thresholds.
    IMPORTANT: You must include ALL fields below for each segment, even if they are not present in the data. If any value is missing, write "Not provided" explicitly.

    Return your output in this exact field-by-field markdown format per segment:

    ### [segment name]

    - **Audience Segment Id**: [UUID]
    - **identityGraphName**: [value]
    - **age_range**: [value] - Matches / Mismatch (explanation)
    - **size**: [value] - Matches / Mismatch (explanation)
    - **income_level**: [value] - Matches / Mismatch (explanation)
    - **location_type**: [value] - Matches / Mismatch (explanation)
    - **recency**: [value] - Matches / Mismatch (explanation)
    - **cpm**: [value] - Matches / Mismatch (explanation if applicable)
    - **cpmCap** [value] - Matches / Mismatch (explanation if applicable)
    - **estReach**: [value] - Matches / Mismatch (explanation if applicable)
    - **programmaticMediaPct**: [value] - Matches / Mismatch (explanation)
    - **advertiserDirectPct**: [value] - Matches / Mismatch (explanation)
    - **confidence**: [value] (state if high, medium, or low — do not flag unless required)
    - **category**: [value] (explanation if applicable)
    - **quality_score**: [value] (explanation)
    - **data_source**: [value] - Matches / Mismatch (explanation if applicable)

    End with a summary like:
    There were [totalMatches] segments that matched your campaign query
    **Summary**: Only segments A and B are fully valid. Segment C is partially valid. Others are not valid.
    
    IMPORTANT: Return an ordered segment list in markdown format with the best matches shown first and the least relevant segments shown last.
    IMPORTANT: Return the best 3-5 segments that match the campaign query, even if they are not perfect matches in markdown format.


  expected_output: >
    Return your output in this exact field-by-field markdown format:
        
    Top segments:
    
    ### [segment name]

    - **Audience Segment Id**: [UUID]
    - **identityGraphName**: [value]
    - **age_range**: [value] - Matches / Mismatch (explanation)
    - **size**: [value] - Matches / Mismatch (explanation)
    - **income_level**: [value] - Matches / Mismatch (explanation)
    - **location_type**: [value] - Matches / Mismatch (explanation)
    - **recency**: [value] - Matches / Mismatch (explanation)
    - **cpm**: [value] - Matches / Mismatch (explanation if applicable)
    - **cpmCap** [value] - Matches / Mismatch (explanation if applicable)
    - **estReach**: [value] - Matches / Mismatch (explanation if applicable)
    - **programmaticMediaPct**: [value] - Matches / Mismatch (explanation)
    - **advertiserDirectPct**: [value] - Matches / Mismatch (explanation)
    - **confidence**: [value] (state if high, medium, or low — do not flag unless required)
    - **category**: [value] (explanation if applicable)
    - **quality_score**: [value] (explanation)
    - **data_source**: [value] - Matches / Mismatch (explanation if applicable)
    
    End with a summary like:
    X total segments match the campaign query.
    **Summary**: Only segments A and B are fully valid. Segment C is partially valid. Others are not valid.
  agent: verifier_agent
  depends_on: [generate_sql_task, select_segment_task]


